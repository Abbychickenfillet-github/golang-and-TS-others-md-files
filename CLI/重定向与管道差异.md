# 重定向 (>) vs 管道 (|) vs PowerShell 差异

## 核心概念

### 管道 `|` (Pipe)
**作用**：把**前一个命令的输出**作为**下一个命令的输入**

```bash
命令1 | 命令2
```

- 数据在**内存中**传递（不写入硬盘）
- 可以无限串接：`cmd1 | cmd2 | cmd3 | cmd4`
- 数据**边产生边处理**（流式处理）

### 重定向 `>` (Redirection)
**作用**：把**命令的输出**存入**文件**

```bash
命令 > 文件名
```

- 数据写入**硬盘**
- 会**覆盖**现有文件（如果文件已存在）
- 产生**持久化**的结果

---

## 实际案例对比

### 场景 1：搜索并查看结果

**使用管道 `|`**（推荐）：
```bash
grep "error" log.txt | less
```
- ✅ 直接查看搜索结果
- ✅ 不产生额外文件
- ✅ 内存效率高

**使用重定向 `>`**：
```bash
grep "error" log.txt > result.txt
cat result.txt
```
- ❌ 产生临时文件
- ❌ 需要两步操作
- ⚠️ 占用硬盘空间

---

### 场景 2：保存处理结果

**使用重定向 `>`**（推荐）：
```bash
grep "error" log.txt | sort | uniq > errors_summary.txt
```
- ✅ 保存最终结果
- ✅ 可以稍后查看
- ✅ 可以分享给他人

**只用管道 `|`**：
```bash
grep "error" log.txt | sort | uniq | less
```
- ⚠️ 只能当场查看
- ❌ 结果不会保存

---

## 使用时机

### 用 `|` 管道的情况：

1. **中间处理**：数据需要经过多个步骤
   ```bash
   cat file.txt | grep "user" | sort | head -10
   ```

2. **实时查看**：不需要保存结果
   ```bash
   docker logs container | grep "error"
   ```

3. **计数统计**：只要最终数字
   ```bash
   ls -l | wc -l
   ```

### 用 `>` 重定向的情况：

1. **保存报告**：需要持久化结果
   ```bash
   mysqldump database > backup.sql
   ```

2. **生成配置文件**：
   ```bash
   echo "port=3306" > config.ini
   ```

3. **导出数据**：
   ```bash
   docker ps -a > container_list.txt
   ```

---

## Bash vs PowerShell 的差异

### 1️⃣ 重定向编码问题

#### Bash (Linux/Mac)
```bash
# UTF-8 编码（标准）
mysqldump database > backup.sql
```
- ✅ 默认 UTF-8 编码
- ✅ 兼容性好

#### PowerShell (Windows)
```powershell
# UTF-16 编码（问题！）
mysqldump database > backup.sql
```
- ❌ 默认 UTF-16 编码
- ❌ 会导致文件编码错误
- ⚠️ 文件大小会变成两倍

**PowerShell 解决方案**：
```powershell
# 方案 1: 使用 Out-File 指定编码
mysqldump database | Out-File -Encoding UTF8 backup.sql

# 方案 2: 使用命令自带的输出参数
mysqldump database --result-file=backup.sql

# 方案 3: 使用 Docker volume 挂载（避免 PowerShell 重定向）
docker run -v C:\sql:/backup mysql mysqldump --result-file=/backup/dump.sql
```

---

### 2️⃣ 管道传递的数据类型

#### Bash
```bash
ls -l | grep "txt"
```
- 📝 传递**纯文本**（字符串）
- 每一行就是一个字符串

#### PowerShell
```powershell
Get-ChildItem | Where-Object {$_.Extension -eq ".txt"}
```
- 🎯 传递 **.NET 对象**
- 每个文件是一个对象，包含属性和方法

**示例：**
```powershell
# Bash 风格（文本处理）
ls | Select-String ".txt"

# PowerShell 风格（对象处理）
Get-ChildItem | Where-Object {$_.Extension -eq ".txt"}
```

---

### 3️⃣ 实际案例对比

#### 案例：导出数据库

**Bash (正确)**：
```bash
mysqldump -h host -u user -p'pass' database > dump.sql
```
✅ 文件编码：UTF-8
✅ 文件大小：正常

**PowerShell (错误)**：
```powershell
mysqldump -h host -u user -p'pass' database > dump.sql
```
❌ 文件编码：UTF-16
❌ 文件内容：每个字符之间有空格
❌ 文件大小：变成两倍

**PowerShell (正确方式 1)**：
```powershell
mysqldump -h host -u user -p'pass' database | Out-File -Encoding UTF8 dump.sql
```
✅ 指定 UTF-8 编码

**PowerShell (正确方式 2 - 推荐)**：
```powershell
docker run --rm -v ${PWD}/sql:/backup mysql:8.0 mysqldump -h host -u user -p'pass' --result-file=/backup/dump.sql database
```
✅ 避开 PowerShell 重定向
✅ 使用 mysqldump 自带的文件输出

---

## 组合使用

### 管道 + 重定向（常见模式）

```bash
# 处理数据，然后保存结果
grep "error" log.txt | sort | uniq > error_summary.txt

# 多步骤处理
cat data.csv | grep "2024" | cut -d',' -f1,3 | sort > result.csv

# 统计并保存
find . -name "*.js" | wc -l > js_file_count.txt
```

**执行顺序**：
```
文件 → grep 过滤 → sort 排序 → uniq 去重 → 存入文件
     ↑ pipe    ↑ pipe     ↑ pipe    ↑ redirect
```

---

## 其他重定向符号

| 符号 | 名称 | 作用 | 示例 |
|------|------|------|------|
| `>` | 输出重定向（覆盖） | 覆盖写入文件 | `echo "hello" > file.txt` |
| `>>` | 输出重定向（追加） | 追加到文件尾 | `echo "world" >> file.txt` |
| `<` | 输入重定向 | 从文件读取输入 | `mysql < script.sql` |
| `2>` | 错误重定向 | 只重定向错误 | `command 2> error.log` |
| `2>&1` | 错误合并到标准输出 | 错误和输出合并 | `command > all.log 2>&1` |
| `&>` | 全部重定向（Bash） | 输出+错误一起重定向 | `command &> all.log` |

---

## 实际案例：mysqldump 导出

### 问题场景

```powershell
# ❌ 错误：使用 PowerShell 重定向
PS> docker run --rm mysql:8.0 mysqldump -h host -u user -p'pass' database > dump.sql

# 结果：
# - 文件编码：UTF-16
# - 文件内容：C R E A T E   T A B L E（每个字符间有空格）
# - 文件大小：从 50KB 变成 200KB
# - 中文注释：变成乱码 ����
```

### 解决方案

**方案 1：使用 Docker volume**（推荐）
```powershell
docker run --rm -v C:\coding\template\sql:/backup mysql:8.0 mysqldump \
  -h host -u user -p'pass' \
  --result-file=/backup/dump.sql \
  database
```
- ✅ 避开 PowerShell 重定向
- ✅ 文件直接在 Docker 容器内生成（UTF-8）
- ✅ 无编码问题

**方案 2：使用 Out-File**
```powershell
docker run --rm mysql:8.0 mysqldump -h host -u user -p'pass' database |
  Out-File -Encoding UTF8 dump.sql
```
- ⚠️ 需要记得加 `-Encoding UTF8`
- ⚠️ 容易忘记导致错误

**方案 3：使用 Git Bash**
```bash
# 在 Git Bash 中执行（推荐）
docker run --rm mysql:8.0 mysqldump -h host -u user -p'pass' database > dump.sql
```
- ✅ Bash 默认 UTF-8
- ✅ 无需额外参数

---

## 记忆口诀

### 管道 `|`
> **"左边输出，右边接收，数据在内存中流动"**

### 重定向 `>`
> **"命令输出，存入文件，数据写进硬盘里"**

### PowerShell 重定向
> **"PowerShell 重定向有陷阱，UTF-16 编码会出错"**
> **"要么用 Out-File 指定 UTF8，要么用 Docker volume 挂载"**

---

## 总结表格

| 符号 | 用途 | 数据流向 | 持久化 | Bash | PowerShell |
|------|------|----------|--------|------|-----------|
| `\|` | 管道 | 命令 → 命令 | ❌ 否 | ✅ UTF-8 文本 | ⚠️ .NET 对象 |
| `>` | 重定向 | 命令 → 文件 | ✅ 是 | ✅ UTF-8 | ❌ UTF-16 |
| `>>` | 追加 | 命令 → 文件 | ✅ 是 | ✅ UTF-8 | ❌ UTF-16 |

---

## 实战技巧

### ✅ 推荐做法

```bash
# 中间处理用管道，最终结果用重定向
cat log.txt | grep "error" | sort | uniq > error_list.txt

# 多个处理步骤串联
ls *.sql | xargs wc -l | sort -n > file_sizes.txt
```

### ❌ 避免做法

```bash
# 不要过度使用临时文件
grep "error" log.txt > temp1.txt
sort temp1.txt > temp2.txt
uniq temp2.txt > final.txt
rm temp1.txt temp2.txt

# 应该用管道一次完成
grep "error" log.txt | sort | uniq > final.txt
```

---

## 作者笔记

**日期**: 2026-01-24

**今天学到**：
1. `|` 是在内存中传数据，`>` 是写文件
2. PowerShell 的 `>` 会用 UTF-16 编码，导致文件变大和乱码
3. 解决方案：用 Docker volume 或 `Out-File -Encoding UTF8`
4. 管道可以无限串联：`cmd1 | cmd2 | cmd3 | cmd4`

**常见错误**：
- 在 PowerShell 用 `>` 导出数据库 → 文件编码错误
- 忘记管道可以串联 → 产生很多临时文件
