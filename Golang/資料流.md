# 資料流架構

> 建立日期: 2026-01-21

---

## 一句話解釋

**資料從資料庫到前端，會經過 5 個轉換層，每一層都有明確的職責。**

---

## 架構流程圖

```
DB Schema → Go Models → DTOs → API Response → Frontend Types
    ↓           ↓          ↓         ↓              ↓
  表結構    GORM 模型   回應格式   JSON 資料    TypeScript 型別
```

---

## 各層詳細說明

### 1. DB Schema（資料庫表結構）

**位置：** Zeabur MySQL / 本地 MySQL

**職責：** 定義資料的實際儲存結構

```sql
CREATE TABLE `user` (
  `id` varchar(36) NOT NULL,
  `email` varchar(255) NOT NULL,
  `hashed_password` varchar(255) NOT NULL,
  `full_name` varchar(255) DEFAULT NULL,
  `is_active` tinyint(1) NOT NULL DEFAULT '1',
  `last_login` datetime DEFAULT NULL,  -- 注意：是 datetime 類型
  PRIMARY KEY (`id`)
);
```

**重點：**
- 這是「真相的來源」(Source of Truth)
- 所有其他層都要跟這裡對齊
- Schema 變更要走 migration，不能隨便改

---

### 2. Go Models（GORM 模型）

**位置：** `backend-go/internal/models/`

**職責：** 將資料庫表映射成 Go struct

```go
// internal/models/user.go
type User struct {
    Base
    Email          string     `gorm:"type:varchar(255);uniqueIndex;not null;column:email" json:"email"`
    HashedPassword string     `gorm:"type:varchar(255);not null;column:hashed_password" json:"-"`
    FullName       *string    `gorm:"type:varchar(255);column:full_name" json:"full_name,omitempty"`
    IsActive       bool       `gorm:"default:true;not null;column:is_active" json:"is_active"`
    LastLogin      *time.Time `gorm:"column:last_login" json:"last_login,omitempty"`  // 對應 DB 的 datetime
}
```

**重點：**
- `gorm` tag 定義資料庫對應
- `json` tag 定義 JSON 序列化（但 Model 通常不直接回傳）
- **類型必須與 DB Schema 一致！**（例如 `datetime` → `*time.Time`，不是 `*int64`）

---

### 3. DTOs（Data Transfer Objects）

**位置：** `backend-go/internal/dto/`

**職責：** 定義 API 的請求/回應格式，**與 Model 解耦**

```go
// internal/dto/user.go

// UserPublic 用戶公開資訊（回應用）
type UserPublic struct {
    ID          string     `json:"id"`
    Email       string     `json:"email"`
    FullName    *string    `json:"full_name,omitempty"`
    IsActive    bool       `json:"is_active"`
    IsSuperuser bool       `json:"is_superuser"`
    LastLogin   *time.Time `json:"last_login,omitempty"`
    // 注意：沒有 HashedPassword，不會回傳給前端
}

// UserCreate 建立用戶請求
type UserCreate struct {
    Email    string  `json:"email" binding:"required,email"`
    Password string  `json:"password" binding:"required,min=8"`
    FullName *string `json:"full_name,omitempty"`
}
```

**重點：**
- **隱藏敏感欄位**（如 `HashedPassword`）
- **控制回傳格式**（可以組合多個 Model 的資料）
- **驗證請求參數**（`binding` tag）

---

### 4. API Response（JSON 回應）

**位置：** `backend-go/internal/handler/`

**職責：** 將 DTO 序列化成 JSON 回傳給前端

```go
// internal/handler/user_handler.go
func (h *UserHandler) GetUser(c *gin.Context) {
    userID := c.Param("id")

    // 1. 從 Service 取得 Model
    user, err := h.userService.GetUser(userID)
    if err != nil {
        c.JSON(404, gin.H{"detail": "User not found"})
        return
    }

    // 2. 轉換成 DTO
    userPublic := dto.UserPublic{
        ID:        user.ID,
        Email:     user.Email,
        FullName:  user.FullName,
        IsActive:  user.IsActive,
        LastLogin: user.LastLogin,
    }

    // 3. 回傳 JSON
    c.JSON(200, userPublic)
}
```

**實際回傳的 JSON：**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "full_name": "王小明",
  "is_active": true,
  "last_login": "2026-01-21T10:30:00Z"
}
```

---

### 5. Frontend Types（TypeScript 型別）

**位置：** `frontend/src/client/models/`

**職責：** 定義前端使用的型別，與 API 回應對應

```typescript
// frontend/src/client/models/auth.ts
export interface UserPublic {
  id: string;
  email: string;
  full_name?: string | null;
  is_active: boolean;
  is_superuser: boolean;
  last_login?: string | null;  // ISO 8601 格式的日期字串
}

export interface UserCreate {
  email: string;
  password: string;
  full_name?: string | null;
}
```

**重點：**
- 型別要與 API Response 一致
- `time.Time` 在 JSON 中是 `string`（ISO 8601 格式）
- 可選欄位用 `?` 和 `| null`

---

## 完整流程範例

### 情境：取得用戶資料

```
1. 前端發送請求
   GET /api/v1/users/123

2. Handler 接收請求
   userHandler.GetUser(c)

3. Service 處理邏輯
   userService.GetUser("123")

4. Repository 查詢資料庫
   SELECT * FROM user WHERE id = '123'

5. GORM 將結果映射到 Model
   user := models.User{...}

6. Handler 將 Model 轉換成 DTO
   userPublic := dto.UserPublic{...}

7. Gin 將 DTO 序列化成 JSON
   {"id": "123", "email": "...", ...}

8. 前端接收 JSON，TypeScript 驗證型別
   const user: UserPublic = response.data
```

---

## 為什麼要分這麼多層？

| 問題 | 解決方案 |
|------|----------|
| 不想回傳 `hashed_password` 給前端 | DTO 只包含要回傳的欄位 |
| 前端需要組合多個 Model 的資料 | DTO 可以自由組合 |
| DB 欄位名稱和 API 欄位名稱不同 | Model 和 DTO 分別定義 |
| 想要驗證請求參數 | DTO 加上 `binding` tag |
| DB Schema 變更時控制影響範圍 | 只需要改 Model，DTO 可以保持不變 |

---

## 常見問題

### Q: Model 和 DTO 有什麼差別？

| 比較 | Model | DTO |
|------|-------|-----|
| 用途 | 對應資料庫表 | 對應 API 請求/回應 |
| 位置 | `internal/models/` | `internal/dto/` |
| 包含 | 所有資料庫欄位 | 只包含需要的欄位 |
| 敏感資料 | 包含（如密碼） | 排除 |

---

### Q: 為什麼 `time.Time` 在前端變成 `string`？

因為 JSON 沒有原生的日期類型。Go 的 `time.Time` 會被序列化成 ISO 8601 字串：

```
Go:     time.Time → 2026-01-21T10:30:00Z
JSON:   string    → "2026-01-21T10:30:00Z"
TS:     string    → "2026-01-21T10:30:00Z"
```

前端使用時要轉換：
```typescript
const lastLogin = new Date(user.last_login);
```

---

### Q: 如果 DB Schema 變了，要改哪些地方？

**依序修改：**

1. **DB Schema** - 執行 migration SQL
2. **Go Models** - 更新 struct 定義
3. **DTOs** - 如果 API 回應要變，更新 DTO
4. **Frontend Types** - 更新 TypeScript interface

**範例：** 新增 `phone` 欄位

```sql
-- 1. DB Schema
ALTER TABLE user ADD COLUMN phone VARCHAR(20);
```

```go
// 2. Go Model
type User struct {
    // ...
    Phone *string `gorm:"type:varchar(20);column:phone" json:"phone,omitempty"`
}

// 3. DTO
type UserPublic struct {
    // ...
    Phone *string `json:"phone,omitempty"`
}
```

```typescript
// 4. Frontend Type
export interface UserPublic {
  // ...
  phone?: string | null;
}
```

---

## 專案檔案對照

| 層級 | 目錄 | 範例檔案 |
|------|------|----------|
| Go Models | `backend-go/internal/models/` | `user.go`, `member.go`, `order.go` |
| DTOs | `backend-go/internal/dto/` | `user.go`, `member.go`, `order.go` |
| Handlers | `backend-go/internal/handler/` | `user_handler.go` |
| Frontend Types | `frontend/src/client/models/` | `auth.ts`, `member.ts`, `order.ts` |

---

## 總結

```
DB Schema    = 資料怎麼存
Go Models   = 資料怎麼讀
DTOs        = 資料怎麼傳
API Response = 資料怎麼回
Frontend Types = 資料怎麼用
```

**黃金法則：每一層都要與上一層對齊，不能自己亂改。**
