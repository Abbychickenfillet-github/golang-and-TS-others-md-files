# 回傳型別符合這個合約 — Interface 與 Struct 的關係

## 起源問題

```go
func NewEventCouponRepository(db *gorm.DB) EventCouponRepository {
    return &eventCouponRepository{db: db}
}
```

>為什麼有兩個 Repository 名字？小寫的 struct 要怎麼給其他地方使用？

## 兩個名字是不同的東西

```go
func NewEventCouponRepository(db *gorm.DB) EventCouponRepository {
//                                          ^^^^^^^^^^^^^^^^^^^^^^^^
//                                          回傳型別 = interface（大寫 E，public）
//                                          「我承諾回傳的東西會符合這個合約」

    return &eventCouponRepository{db: db}
//          ^^^^^^^^^^^^^^^^^^^^^^^^
//          實際建立的 = struct（小寫 e，private）
//          「但實際上我建立的是這個具體的實作」
}
```

### 餐廳類比
```
EventCouponRepository（interface）= 菜單上寫「牛肉麵」
eventCouponRepository（struct）   = 廚房裡實際煮出來的那碗牛肉麵

客人（service）只看菜單點餐，不需要知道廚房怎麼煮的
```

## 小寫的 struct 怎麼給別人用？→ 透過 interface

別人不會直接碰 struct，而是透過建構函式拿到 interface：

```go
// ❌ 別人不能直接用 struct（小寫 = private）
repo := eventCouponRepository{db: db}  // 編譯錯誤！外部看不到

// ✅ 別人透過建構函式，拿到的是 interface（大寫 = public）
repo := NewEventCouponRepository(db)   // 回傳 EventCouponRepository interface
repo.GetByID(1)                        // 只能用 interface 定義的方法
```

### 流程圖
```
service（在別的 package）
    │
    │  需要用 repository
    │
    ├── 1. 呼叫 NewEventCouponRepository(db)  ← 大寫 N，public 函式
    │       回傳 EventCouponRepository         ← 大寫 E，public interface
    │
    ├── 2. 拿到 interface，可以用：
    │       repo.GetByID(1)      ✅
    │       repo.Create(coupon)  ✅
    │
    └── 3. 但不知道裡面是什麼 struct：
            repo.db              ❌  看不到，也不需要知道
```

## TypeScript 類比

```typescript
// repository.ts
interface EventCouponRepository {        // export（公開）
    getByID(id: number): Promise<EventCoupon>
}

class EventCouponRepositoryImpl {        // 不 export（私有）
    private db: Database
    getByID(id: number) { /* 用 this.db 查資料 */ }
}

// 只 export 建構函式和 interface，不 export class
export function newEventCouponRepository(db: Database): EventCouponRepository {
    return new EventCouponRepositoryImpl(db)
}
```

```typescript
// service.ts — 使用方
import { newEventCouponRepository, EventCouponRepository } from './repository'

const repo: EventCouponRepository = newEventCouponRepository(db)
repo.getByID(1)    // ✅ 能用 interface 的方法

// ❌ 不能直接用 class，因為沒有 export
const repo2 = new EventCouponRepositoryImpl(db)  // 錯誤！
```

## 為什麼要藏起來 struct？

```
公開的（大寫）              私有的（小寫）
───────────────            ──────────────
interface                  struct
  → 你能做什麼               → 怎麼做的（實作細節）
  → 菜單                     → 廚房食譜
  → 合約                     → 內部作業流程

NewXxx() 建構函式          struct 的內部欄位
  → 餐廳門口                 → 廚房（客人進不去）
```

**只公開「能做什麼」，隱藏「怎麼做」**。
好處：以後換實作（換廚房），用的人完全不受影響。

```go
// 正式環境 → 用真的資料庫
repo := NewEventCouponRepository(realDB)

// 測試環境 → 用 mock，不連資料庫
repo := NewMockEventCouponRepository()

// service 不用改任何程式碼，因為它只認 interface（合約）
```

## 命名大小寫補充

不是 `R` 大寫決定 public/private，是**整個名字的第一個字母**：

```go
EventCouponRepository   // E 大寫 → public（PascalCase）
eventCouponRepository   // e 小寫 → private（camelCase）

// 中間的 C、R 大寫只是 camelCase 的分詞，跟 public/private 無關
```

| 命名風格 | Go 的意思 | JavaScript 的對應 |
|---------|----------|------------------|
| `PascalCase` | public（exported） | class 名稱、React 元件 |
| `camelCase` | private（unexported） | 變數名、函式名 |

## 回傳的不是型別本身，是「符合那個型別的值」

### 問題：回傳的東西就是型別嗎？為什麼可以回傳型別？

答案：**不是回傳型別，是回傳一個「值」**，只是這個值必須符合宣告的型別。

```go
func NewEventCouponRepository(db *gorm.DB) EventCouponRepository {
//                                          ^^^^^^^^^^^^^^^^^^^^^^^^
//                                          這不是「回傳型別本身」
//                                          這是「承諾：我回傳的值會符合這個 interface」

    // 中間可以做任何事情，不會影響回傳型別
    fmt.Println("建立 repository")
    log.Info("connecting...")

    // 最後回傳的是一個「值」（struct 實例），不是型別
    return &eventCouponRepository{db: db}
//         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//         這才是真正回傳的東西
}
```

### TypeScript 類比（你最熟悉的）
```typescript
function createRepo(db: Database): EventCouponRepository {
//                                  ^^^^^^^^^^^^^^^^^^^^^^^^
//                                  這是回傳型別「宣告」，不是回傳值
    console.log("建立 repository")   // 中間做什麼都行
    return new EventCouponRepositoryImpl(db)  // 回傳的是物件，不是型別
}

// 就像你不會說這個函式「回傳 string 型別」：
function greet(): string {
    return "hello"   // 回傳的是 "hello" 這個值，不是 string 這個型別
}
```

### 中間做事情會改到型別嗎？不會
```go
func NewEventCouponRepository(db *gorm.DB) EventCouponRepository {
    fmt.Println("hello")           // ← 不影響回傳型別
    time.Sleep(1 * time.Second)    // ← 不影響回傳型別
    count := db.RowsAffected       // ← 不影響回傳型別

    // 唯一的規則：最後 return 的東西必須符合 EventCouponRepository interface
    return &eventCouponRepository{db: db}  // ✅ 符合合約就行
}
```

### 一句話總結
```
func Xxx() EventCouponRepository { ... }
           ^^^^^^^^^^^^^^^^^^^^^^^^
           「承諾回傳的值會符合這個 interface」
           不是「回傳這個 interface 本身」

就像 TypeScript 的 function xxx(): string { return "hello" }
                                   ^^^^^^
           「承諾回傳的值是 string」，不是「回傳 string 這個型別」
```