# Git Add -p 互動式暫存教學

## 什麼是 `git add -p`？

`git add -p` (patch mode) 是一個互動式工具，讓你可以**選擇性地暫存檔案中的部分變更**，而不是一次暫存整個檔案。這對於將不同功能的修改分成獨立的 commit 非常有用。

## 基本使用方式

```bash
git add -p [檔案名稱]
```

如果不指定檔案名稱，會對所有已修改的檔案逐一處理。

## Hunk 是什麼？

Git 會將檔案的變更分成多個 **hunk（區塊）**，每個 hunk 代表一段連續的變更。

### Hunk 標頭格式

```
@@ -109,6 +109,45 @@ function someFunction() {
```

這個標頭的意義：
- `@@ ... @@` - hunk 標頭的開始和結束標記
- `-109,6` - **舊檔案**：從第 109 行開始，共 6 行
- `+109,45` - **新檔案**：從第 109 行開始，共 45 行
- `function someFunction()` - 上下文提示（最近的函數/類別名稱）

### 解讀範例

| 標頭 | 意義 |
|------|------|
| `@@ -10,5 +10,8 @@` | 舊檔案 10 行起共 5 行，新檔案 10 行起共 8 行（新增 3 行） |
| `@@ -20,10 +20,7 @@` | 舊檔案 20 行起共 10 行，新檔案 20 行起共 7 行（刪除 3 行） |
| `@@ -1,0 +1,15 @@` | 舊檔案該位置為空，新增了 15 行 |

## 互動選項

當顯示一個 hunk 時，Git 會詢問你要如何處理：

| 選項 | 說明 |
|------|------|
| `y` | **Yes** - 暫存這個 hunk |
| `n` | **No** - 不暫存這個 hunk |
| `q` | **Quit** - 退出，不暫存剩餘的 hunk |
| `a` | **All** - 暫存這個檔案剩餘的所有 hunk |
| `d` | **Don't** - 不暫存這個檔案剩餘的所有 hunk |
| `s` | **Split** - 嘗試將這個 hunk 分割成更小的 hunk |
| `e` | **Edit** - 手動編輯這個 hunk |
| `?` | 顯示說明 |

## 實戰範例

### 情境：一個檔案有三個不同功能的修改

假設你在 `page.tsx` 中做了三個修改：
1. 新增 Undo 功能
2. 新增命名模式
3. 修改提示樣式

你想分成三個 commit。

### 步驟

```bash
# 1. 開始互動式暫存
git add -p page.tsx

# 2. Git 會顯示第一個 hunk
# @@ -109,6 +109,45 @@ ...
# 這是 Undo 功能的程式碼
# Stage this hunk [y,n,q,a,d,s,e,?]?

# 輸入 y 暫存這個 hunk

# 3. 繼續處理下一個 hunk
# @@ -200,10 +200,50 @@ ...
# 這是命名模式的程式碼
# 輸入 n 跳過

# 4. 處理第三個 hunk
# @@ -300,5 +300,25 @@ ...
# 這是提示樣式的程式碼
# 輸入 n 跳過

# 5. 完成後，只有 Undo 功能被暫存
git commit -m "feat: 新增 Undo 功能"

# 6. 重複步驟，這次只選 y 命名模式的 hunk
git add -p page.tsx
# 輸入 n, y, n...
git commit -m "feat: 新增命名模式"

# 7. 最後暫存剩餘的修改
git add -p page.tsx
# 輸入 n, n, y...
git commit -m "style: 修改提示樣式"
```

## 進階技巧

### 1. 使用腳本自動選擇

如果你已經知道要選擇哪些 hunk，可以用 `printf` 或 `echo` 管道輸入：

```bash
# 選擇 第1個 y, 第2個 n, 第3個 y
printf 'y\nn\ny\n' | git add -p

# 或使用 echo
echo -e "y\nn\ny" | git add -p
```

### 2. 分割 Hunk (s 選項)

當一個 hunk 包含多個不相關的修改時，使用 `s` 來分割：

```bash
# Git 顯示一個大 hunk
Stage this hunk [y,n,q,a,d,s,e,?]? s

# Git 會嘗試將它分成更小的 hunk
# 注意：只有當修改之間有足夠的未修改行時才能分割
```

### 3. 手動編輯 Hunk (e 選項)

當 `s` 無法進一步分割時，使用 `e` 手動編輯：

```bash
Stage this hunk [y,n,q,a,d,s,e,?]? e
```

編輯器會開啟，你可以：
- 刪除以 `+` 開頭的行 → 該新增不會被暫存
- 將 `-` 開頭改為空格 → 該刪除不會被暫存
- **不要**刪除以 `-` 開頭的行（會破壞 patch）

### 4. 查看已暫存 vs 未暫存

```bash
# 查看已暫存的變更
git diff --staged

# 查看未暫存的變更
git diff

# 查看所有變更（暫存 + 未暫存）
git diff HEAD
```

## 常見問題

### Q: 為什麼 `s` 選項無法分割？

A: 只有當修改之間有「至少 3 行未修改的程式碼」時，Git 才能分割 hunk。連續的修改無法分割。

### Q: 我選錯了怎麼辦？

A: 使用 `git reset HEAD <檔案>` 取消暫存，重新來過：

```bash
git reset HEAD page.tsx
git add -p page.tsx
```

### Q: 如何只暫存新增的行，不暫存刪除的行？

A: 使用 `e` 選項手動編輯 hunk，將 `-` 開頭的行改為空格（保持原樣）。

## 最佳實踐

1. **開發時就分開修改** - 每次只修改一個功能，立即 commit
2. **使用 `git diff` 先預覽** - 在 `add -p` 前先看一下有哪些修改
3. **小 commit 勝過大 commit** - 每個 commit 應該只做一件事
4. **寫好 commit message** - 說明「為什麼」而不是「做了什麼」

## 快速參考卡

```
┌─────────────────────────────────────────┐
│           git add -p 快速參考            │
├─────────────────────────────────────────┤
│ y - 暫存這個 hunk                        │
│ n - 跳過這個 hunk                        │
│ s - 分割成更小的 hunk                    │
│ e - 手動編輯 hunk                        │
│ q - 退出                                 │
├─────────────────────────────────────────┤
│ @@ -舊行,舊數量 +新行,新數量 @@          │
│ 例: @@ -10,5 +10,8 @@ 表示              │
│    舊檔案第10行起5行 → 新檔案第10行起8行  │
└─────────────────────────────────────────┘
```

---

*最後更新：2025-12-26*
