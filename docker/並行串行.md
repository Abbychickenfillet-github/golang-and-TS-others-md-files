# Docker Compose 並行 vs 串行建構

## 問題情境

執行 `docker compose up --build backend` 時出現錯誤：
```
ERROR: image "docker.io/library/futuresignreg.combackend:latest": already exists
```

## 原因

`docker-compose.yml` 中 `backend` 和 `prestart` 使用**同一個 image name**：
```yaml
prestart:
  image: '${DOMAIN}${DOCKER_IMAGE_BACKEND}:latest'  # 同一個！

backend:
  image: '${DOMAIN}${DOCKER_IMAGE_BACKEND}:latest'  # 同一個！
```

## 並行 vs 串行差異

```
並行 (Parallel) - 同時做
━━━━━━━━━━━━━━━━━━━━━━━━
時間 →
backend:   ████████████ → 寫入 image
prestart:  ████████████ → 寫入 image
                              ↓
                         同時寫入同一個名字 → 衝突！


串行 (Sequential) - 排隊做
━━━━━━━━━━━━━━━━━━━━━━━━
時間 →
backend:   ████████████ → 寫入 image ✅
prestart:              ████████████ → 發現已存在，跳過 ✅
```

## 解決方案

```bash
# 方法 1: 限制並行數為 1（串行建構）
COMPOSE_PARALLEL_LIMIT=1 docker compose build backend && docker compose up -d backend

# 方法 2: 不重建，直接啟動（用已存在的 image）
docker compose up -d backend

# 方法 3: 先刪除 image 再建構
docker rmi futuresignreg.combackend:latest
docker compose up -d --build backend
```

## 常用指令整理

| 指令 | 說明 |
|------|------|
| `docker compose up -d backend` | 只啟動 backend（含依賴 redis, prestart） |
| `docker compose up -d --build backend` | 重建並啟動 backend |
| `docker compose up --build` | 重建並啟動**所有服務**（包含 nginx, frontend 等） |
| `docker compose down` | 停止並移除所有容器 |

## 生活比喻

| 並行 | 串行 |
|------|------|
| 兩個人同時搶同一個廁所 | 一個人用完，下一個再進去 |
| 兩台車同時過單線道 | 一台過完，另一台再過 |

---

# Claude 調查錯誤檢討 (2026-01-14)

## 事件經過

用戶報告：在 port 3000 的 `/event/register/booth` 頁面 F12 有 CORS error

## Claude 的調查過程

1. 檢查 CORS 配置 → `localhost:3000` 在白名單中 ✅
2. 測試 API → 發現 500 Internal Server Error
3. 查看 Docker 日誌 → 發現 Redis 連接錯誤
4. 重啟 Redis → API 恢復正常
5. 結論：Redis 停止導致 500 錯誤

## 真正的問題

用戶實際訪問的是 `http://172.18.16.1:3000`，不是 `http://localhost:3000`！

`172.18.16.1` 是 Docker 內部網路 IP，**不在 CORS 白名單中**。

## Claude 的錯誤

1. **沒有先問清楚用戶的訪問 URL** - 直接假設是 localhost:3000
2. **過早下結論** - 看到 Redis 錯誤就認定是根本原因
3. **沒有驗證 CORS 的完整路徑** - 只測試了 localhost，沒測試實際 IP

## 正確的調查步驟

1. **先問用戶**：「你是用什麼 URL 訪問的？」
2. **檢查瀏覽器 Network 面板**：看 Request URL 和 Origin header
3. **確認 CORS 白名單**：是否包含用戶實際使用的 origin
4. **再深入調查**：後端日誌、Redis 狀態等

## 教訓

> 不要假設，先確認用戶的實際操作環境！

## 修復方案

如果需要支援 Docker 內部 IP 訪問，在 `.env` 的 `BACKEND_CORS_ORIGINS` 加入：
```
http://172.18.16.1:3000
```

或建議用戶使用 `http://localhost:3000` 訪問。
